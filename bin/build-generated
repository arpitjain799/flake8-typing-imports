#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import re
import subprocess
from typing import Any

TAG_RE = re.compile(r'^v[0-9.]+$')


def get_tag_list(repo: str) -> tuple[str, ...]:
    subprocess.check_call(('git', '-C', repo, 'fetch', '-q', '--tags'))
    out = subprocess.check_output(('git', '-C', repo, 'tag', '--list'))
    return tuple(out.decode().splitlines())


PROG = '''\
import json
import sys
globs = {'__name__': 'typing'}
exec(compile(sys.stdin.read(), '<typing>', 'exec'), globs)
_typing = type('typing', (), globs)
print(json.dumps([
    k for k, v in vars(_typing).items()
    if k not in {'io', 're'}
    if k in _typing.__all__ or (
        # avoid private names
        not k.startswith('_') and
        # there's a few types and metaclasses that aren't exported
        not k.endswith(('Meta', '_contra', '_co')) and
        not k.upper() == k and
        # but export all things that have __module__ == 'typing'
        getattr(v, '__module__', None) == _typing.__name__
    )
] + _typing.io.__all__ + _typing.re.__all__))
'''


def get_defined_names(v: tuple[int, ...], s: bytes) -> set[str]:
    """The __all__ of typing is very unreliable: bpo-36983"""
    proc = subprocess.run(
        (f'python{v[0]}.{v[1]}', '-c', PROG),
        input=s,
        stdout=subprocess.PIPE,
        check=True,
    )
    ret = set(json.loads(proc.stdout))
    # Final in these versions isn't the type it eventually becomes
    if v < (3, 5, 3):
        ret.discard('Final')
    return ret


def compare(old: str, new: str) -> None:
    old_dct: dict[str, Any] = {'Version': lambda *a: a}
    exec(old, old_dct)
    new_dct: dict[str, Any] = {'Version': lambda *a: a}
    exec(new, new_dct)
    for (v, k_old), (_, k_new) in zip(old_dct['SYMBOLS'], new_dct['SYMBOLS']):
        print(str(v).center(79, '='))
        for added in sorted(k_new - k_old):
            print(f'+{added}')
        for removed in sorted(k_old - k_new):
            print(f'-{removed}')


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('cpython')
    args = parser.parse_args()

    ret = []
    for tag in get_tag_list(args.cpython):
        if not TAG_RE.match(tag):
            continue
        version = tuple(int(p) for p in tag[1:].split('.'))
        if version < (3, 5):
            continue
        cmd = ('git', '-C', args.cpython, 'show', f'{tag}:Lib/typing.py')
        names = get_defined_names(version, subprocess.check_output(cmd))
        ret.append((version, names))

    parts = ['SYMBOLS = (']
    for version, symbols_set in sorted(ret):
        symbols = sorted(symbols_set)
        parts.append('    (')
        vstr = ', '.join(str(p) for p in version)
        parts.append(f'        Version({vstr}), frozenset((')
        accum = f'            {symbols[0]!r},'
        for symbol in symbols[1:]:
            if len(accum) + len(repr(symbol)) + 2 < 80:
                accum += f' {symbol!r},'
            else:
                parts.append(f'{accum}')
                accum = f'            {symbol!r},'
        parts.append(f'{accum}')
        parts.append('        )),')
        parts.append('    ),')
    parts.append(')')
    new = '\n'.join(parts) + '\n'

    with open('flake8_typing_imports.py') as f:
        contents = f.read()

    p1, p2, rest = contents.partition('# GENERATED BY ./bin/build-generated\n')
    old, p3, p4 = rest.partition('# END GENERATED\n')

    with open('flake8_typing_imports.py', 'w') as f:
        f.write(p1 + p2 + new + p3 + p4)

    compare(old, new)

    return 0


if __name__ == '__main__':
    raise SystemExit(main())
